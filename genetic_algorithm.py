# -*- coding: utf-8 -*-
"""Genetic Algorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19O7bdAxFr5D1njDq7alurs7circ3BQ6C

**Genetic Algorithm**
"""

import random

"""Let say we have fucntion that evaluates the expression to 0 if the answer of expression " 6 * x ** 3 + 9 * y ** 2 + 90 * z " is 25.
So That's mean we need the most suitable values of x, y and z so that we could achive our target value whichis 25 in this case.
"""

def evaluateExpression(x, y, z):
	return 6 * x ** 3 + 9 * y ** 2 + 90 * z - 25

"""Let's write the solution based on Genetic Algorithm technique to find the most suitable values of x, y and z.

*Step1* : Population of Solutions:
Population is generated entirely from random numbers let say upto 1000 indivuduals.
"""

# generate solutions
solutions = []
for counter in range(1000):
	solutions.append((random.uniform(0, 1000), random.uniform(0, 1000), random.uniform(0, 1000)))

"""Step2: Fitness fucntion:
So the most fittest solution will be the one which evalutes the expression to "0". Otherwise the best solution will be closest to zero.
So the fittness in this case can be seen if the solution is closest to zero. Hnece we can return highest fitness value to those solution which are closest to zero.
"""

def fitness(x, y, z):
	ans = evaluateExpression(x, y, z)

	if ans == 0:
		return 99999
	else:
		return abs(1 / ans)

"""Step3: Mating, Crossover or Generating the Genrations:
During each generations further sub steps are performed like :
Step 3.1: Selection of top ranked solutions
Step 3.2: Mutation or slight changes or variation in values of solution.
P.S(Here for the sake of anology if solution can be considered as chromosome then vatiable values can be considered as genes)

"""

for generation_count in range(10000):
	rankedSolutions = []
  # fitness step
	for solution in solutions:
		rankedSolutions.append((fitness(solution[0], solution[1], solution[2]), solution))
	rankedSolutions.sort()
	rankedSolutions.reverse()
	print(f"=== Generation {generation_count} best solutions ====")
	print(rankedSolutions[0])

	if rankedSolutions[0][0] > 999:
		break

	bestSolution = rankedSolutions[:100]
	# print(bestSolution)

  # selection step
	variables = []
	for solution in bestSolution:
		variables.append(solution[1][0])  # variable x
		variables.append(solution[1][1])  # variable y
		variables.append(solution[1][2])  # variable z

	newGeneration = []
  # mutation step
	for counter in range(1000):
		x = random.choice(variables) * random.uniform(0.99, 1.01)
		y = random.choice(variables) * random.uniform(0.99, 1.01)
		z = random.choice(variables) * random.uniform(0.99, 1.01)

		newGeneration.append((x, y, z))

	solutions = newGeneration

import numpy as np

#Items available
items = [[3, 266],
    [13, 442],
    [10, 671],
    [9, 526],
    [7, 388],
    [1, 245],
    [8, 210],
    [8, 145],
    [2, 126],
    [9, 322]
]
Items = np.array(items)

#initial population
Population = [[0, 1, 0, 1, 1, 0, 0, 1, 1, 1],
 [1, 1, 1, 1, 0, 1, 1, 1, 0, 0],
 [0, 1, 0, 0, 0, 0, 1, 1, 0, 1],
 [0, 0, 1, 0, 1, 1, 0, 0, 0, 0],
 [0, 0, 1, 1, 0, 0, 0, 0, 0, 1],
 [0, 1, 0, 1, 1, 0, 1, 0, 0, 0],
 [1, 1, 1, 0, 0, 0, 1, 0, 1, 0],
 [0, 0, 0, 0, 1, 1, 1, 0, 0, 0]]

Initialpopulation = np.array(Population)

# Maximum weight the bag can carry
AllowedWeight = 35

# Fitness Function
def fitness(chromosome):
    TotalValue = np.sum(chromosome * items[:, 1])  # Calculate total value
    TotalWeight = np.sum(chromosome * items[:, 0])  # Calculate total weight
    if TotalWeight <= AllowedWeight:
        return TotalValue
    else:
        return 0

"""
n = chromosome length
Ci = ith gene
Vi = ith value
Wi = ith weight
kw = allowed weight
"""

# Two-point Crossover
def crossover(parent1, parent2):
    crossover_point1 = np.random.randint(1, len(parent1) - 2)
    crossover_point2 = np.random.randint(crossover_point1 + 1, len(parent1) - 1)
    child1 = np.concatenate((parent1[:crossover_point1], parent2[crossover_point1:crossover_point2], parent1[crossover_point2:]))
    child2 = np.concatenate((parent2[:crossover_point1], parent1[crossover_point1:crossover_point2], parent2[crossover_point2:]))
    return child1, child2

#Mutation
def mutation(child):
    mutation_points = np.random.choice(len(child), 2, replace=False)
    child[mutation_points[0]] = 1 - child[mutation_points[0]]
    child[mutation_points[1]] = 1 - child[mutation_points[1]]
    return child

#Generate new population
def generate_new_population(current_population):
    new_population = []
    elite_count = len(current_population) // 2  # Keep 50% best chromosomes
    elite_population = current_population[np.argsort([fitness(chromosome) for chromosome in current_population])[::-1][:elite_count]]

    while len(new_population) < len(current_population):
        elite_indices = np.arange(len(elite_population))
        np.random.shuffle(elite_indices)
        parent1, parent2 = elite_population[elite_indices[0]], elite_population[elite_indices[1]]
        child1, child2 = crossover(parent1, parent2)
        child1 = mutation(child1)
        child2 = mutation(child2)
        new_population.extend([child1, child2])

    return np.array(new_population)

# Genetic Algorithm
population = np.array(Initialpopulation)
for i in range(20): #number of iterations
    population = generate_new_population(population)

#Select the best chromosome
best_chromosome = population[np.argmax([fitness(chromosome) for chromosome in population])]
print("Best Chromosome:", best_chromosome)
print("Total Value:", fitness(best_chromosome))